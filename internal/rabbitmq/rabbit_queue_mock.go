package rabbitmq

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

//go:generate minimock -i gitlab.com/voipbin/bin-manager/call-manager/internal/rabbitmq.RabbitQueue -o ./rabbit_queue_mock.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RabbitQueueMock implements RabbitQueue
type RabbitQueueMock struct {
	t minimock.Tester

	funcClose          func()
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mRabbitQueueMockClose

	funcConnect          func()
	inspectFuncConnect   func()
	afterConnectCounter  uint64
	beforeConnectCounter uint64
	ConnectMock          mRabbitQueueMockConnect

	funcConsumeMessage          func(consumerName string, messageConsume CbMsgConsume)
	inspectFuncConsumeMessage   func(consumerName string, messageConsume CbMsgConsume)
	afterConsumeMessageCounter  uint64
	beforeConsumeMessageCounter uint64
	ConsumeMessageMock          mRabbitQueueMockConsumeMessage

	funcConsumeRPC          func(consumerName string, cbRPC CbMsgRPC)
	inspectFuncConsumeRPC   func(consumerName string, cbRPC CbMsgRPC)
	afterConsumeRPCCounter  uint64
	beforeConsumeRPCCounter uint64
	ConsumeRPCMock          mRabbitQueueMockConsumeRPC

	funcPublishMessage          func(message string)
	inspectFuncPublishMessage   func(message string)
	afterPublishMessageCounter  uint64
	beforePublishMessageCounter uint64
	PublishMessageMock          mRabbitQueueMockPublishMessage
}

// NewRabbitQueueMock returns a mock for RabbitQueue
func NewRabbitQueueMock(t minimock.Tester) *RabbitQueueMock {
	m := &RabbitQueueMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mRabbitQueueMockClose{mock: m}

	m.ConnectMock = mRabbitQueueMockConnect{mock: m}

	m.ConsumeMessageMock = mRabbitQueueMockConsumeMessage{mock: m}
	m.ConsumeMessageMock.callArgs = []*RabbitQueueMockConsumeMessageParams{}

	m.ConsumeRPCMock = mRabbitQueueMockConsumeRPC{mock: m}
	m.ConsumeRPCMock.callArgs = []*RabbitQueueMockConsumeRPCParams{}

	m.PublishMessageMock = mRabbitQueueMockPublishMessage{mock: m}
	m.PublishMessageMock.callArgs = []*RabbitQueueMockPublishMessageParams{}

	return m
}

type mRabbitQueueMockClose struct {
	mock               *RabbitQueueMock
	defaultExpectation *RabbitQueueMockCloseExpectation
	expectations       []*RabbitQueueMockCloseExpectation
}

// RabbitQueueMockCloseExpectation specifies expectation struct of the RabbitQueue.Close
type RabbitQueueMockCloseExpectation struct {
	mock *RabbitQueueMock

	Counter uint64
}

// Expect sets up expected params for RabbitQueue.Close
func (mmClose *mRabbitQueueMockClose) Expect() *mRabbitQueueMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RabbitQueueMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RabbitQueueMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the RabbitQueue.Close
func (mmClose *mRabbitQueueMockClose) Inspect(f func()) *mRabbitQueueMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for RabbitQueueMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by RabbitQueue.Close
func (mmClose *mRabbitQueueMockClose) Return() *RabbitQueueMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RabbitQueueMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RabbitQueueMockCloseExpectation{mock: mmClose.mock}
	}

	return mmClose.mock
}

//Set uses given function f to mock the RabbitQueue.Close method
func (mmClose *mRabbitQueueMockClose) Set(f func()) *RabbitQueueMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the RabbitQueue.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the RabbitQueue.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements RabbitQueue
func (mmClose *RabbitQueueMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to RabbitQueueMock.Close.")

}

// CloseAfterCounter returns a count of finished RabbitQueueMock.Close invocations
func (mmClose *RabbitQueueMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of RabbitQueueMock.Close invocations
func (mmClose *RabbitQueueMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *RabbitQueueMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *RabbitQueueMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RabbitQueueMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to RabbitQueueMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to RabbitQueueMock.Close")
	}
}

type mRabbitQueueMockConnect struct {
	mock               *RabbitQueueMock
	defaultExpectation *RabbitQueueMockConnectExpectation
	expectations       []*RabbitQueueMockConnectExpectation
}

// RabbitQueueMockConnectExpectation specifies expectation struct of the RabbitQueue.Connect
type RabbitQueueMockConnectExpectation struct {
	mock *RabbitQueueMock

	Counter uint64
}

// Expect sets up expected params for RabbitQueue.Connect
func (mmConnect *mRabbitQueueMockConnect) Expect() *mRabbitQueueMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("RabbitQueueMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &RabbitQueueMockConnectExpectation{}
	}

	return mmConnect
}

// Inspect accepts an inspector function that has same arguments as the RabbitQueue.Connect
func (mmConnect *mRabbitQueueMockConnect) Inspect(f func()) *mRabbitQueueMockConnect {
	if mmConnect.mock.inspectFuncConnect != nil {
		mmConnect.mock.t.Fatalf("Inspect function is already set for RabbitQueueMock.Connect")
	}

	mmConnect.mock.inspectFuncConnect = f

	return mmConnect
}

// Return sets up results that will be returned by RabbitQueue.Connect
func (mmConnect *mRabbitQueueMockConnect) Return() *RabbitQueueMock {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("RabbitQueueMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &RabbitQueueMockConnectExpectation{mock: mmConnect.mock}
	}

	return mmConnect.mock
}

//Set uses given function f to mock the RabbitQueue.Connect method
func (mmConnect *mRabbitQueueMockConnect) Set(f func()) *RabbitQueueMock {
	if mmConnect.defaultExpectation != nil {
		mmConnect.mock.t.Fatalf("Default expectation is already set for the RabbitQueue.Connect method")
	}

	if len(mmConnect.expectations) > 0 {
		mmConnect.mock.t.Fatalf("Some expectations are already set for the RabbitQueue.Connect method")
	}

	mmConnect.mock.funcConnect = f
	return mmConnect.mock
}

// Connect implements RabbitQueue
func (mmConnect *RabbitQueueMock) Connect() {
	mm_atomic.AddUint64(&mmConnect.beforeConnectCounter, 1)
	defer mm_atomic.AddUint64(&mmConnect.afterConnectCounter, 1)

	if mmConnect.inspectFuncConnect != nil {
		mmConnect.inspectFuncConnect()
	}

	if mmConnect.ConnectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnect.ConnectMock.defaultExpectation.Counter, 1)

		return

	}
	if mmConnect.funcConnect != nil {
		mmConnect.funcConnect()
		return
	}
	mmConnect.t.Fatalf("Unexpected call to RabbitQueueMock.Connect.")

}

// ConnectAfterCounter returns a count of finished RabbitQueueMock.Connect invocations
func (mmConnect *RabbitQueueMock) ConnectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.afterConnectCounter)
}

// ConnectBeforeCounter returns a count of RabbitQueueMock.Connect invocations
func (mmConnect *RabbitQueueMock) ConnectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.beforeConnectCounter)
}

// MinimockConnectDone returns true if the count of the Connect invocations corresponds
// the number of defined expectations
func (m *RabbitQueueMock) MinimockConnectDone() bool {
	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnect != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		return false
	}
	return true
}

// MinimockConnectInspect logs each unmet expectation
func (m *RabbitQueueMock) MinimockConnectInspect() {
	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RabbitQueueMock.Connect")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		m.t.Error("Expected call to RabbitQueueMock.Connect")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnect != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		m.t.Error("Expected call to RabbitQueueMock.Connect")
	}
}

type mRabbitQueueMockConsumeMessage struct {
	mock               *RabbitQueueMock
	defaultExpectation *RabbitQueueMockConsumeMessageExpectation
	expectations       []*RabbitQueueMockConsumeMessageExpectation

	callArgs []*RabbitQueueMockConsumeMessageParams
	mutex    sync.RWMutex
}

// RabbitQueueMockConsumeMessageExpectation specifies expectation struct of the RabbitQueue.ConsumeMessage
type RabbitQueueMockConsumeMessageExpectation struct {
	mock   *RabbitQueueMock
	params *RabbitQueueMockConsumeMessageParams

	Counter uint64
}

// RabbitQueueMockConsumeMessageParams contains parameters of the RabbitQueue.ConsumeMessage
type RabbitQueueMockConsumeMessageParams struct {
	consumerName   string
	messageConsume CbMsgConsume
}

// Expect sets up expected params for RabbitQueue.ConsumeMessage
func (mmConsumeMessage *mRabbitQueueMockConsumeMessage) Expect(consumerName string, messageConsume CbMsgConsume) *mRabbitQueueMockConsumeMessage {
	if mmConsumeMessage.mock.funcConsumeMessage != nil {
		mmConsumeMessage.mock.t.Fatalf("RabbitQueueMock.ConsumeMessage mock is already set by Set")
	}

	if mmConsumeMessage.defaultExpectation == nil {
		mmConsumeMessage.defaultExpectation = &RabbitQueueMockConsumeMessageExpectation{}
	}

	mmConsumeMessage.defaultExpectation.params = &RabbitQueueMockConsumeMessageParams{consumerName, messageConsume}
	for _, e := range mmConsumeMessage.expectations {
		if minimock.Equal(e.params, mmConsumeMessage.defaultExpectation.params) {
			mmConsumeMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConsumeMessage.defaultExpectation.params)
		}
	}

	return mmConsumeMessage
}

// Inspect accepts an inspector function that has same arguments as the RabbitQueue.ConsumeMessage
func (mmConsumeMessage *mRabbitQueueMockConsumeMessage) Inspect(f func(consumerName string, messageConsume CbMsgConsume)) *mRabbitQueueMockConsumeMessage {
	if mmConsumeMessage.mock.inspectFuncConsumeMessage != nil {
		mmConsumeMessage.mock.t.Fatalf("Inspect function is already set for RabbitQueueMock.ConsumeMessage")
	}

	mmConsumeMessage.mock.inspectFuncConsumeMessage = f

	return mmConsumeMessage
}

// Return sets up results that will be returned by RabbitQueue.ConsumeMessage
func (mmConsumeMessage *mRabbitQueueMockConsumeMessage) Return() *RabbitQueueMock {
	if mmConsumeMessage.mock.funcConsumeMessage != nil {
		mmConsumeMessage.mock.t.Fatalf("RabbitQueueMock.ConsumeMessage mock is already set by Set")
	}

	if mmConsumeMessage.defaultExpectation == nil {
		mmConsumeMessage.defaultExpectation = &RabbitQueueMockConsumeMessageExpectation{mock: mmConsumeMessage.mock}
	}

	return mmConsumeMessage.mock
}

//Set uses given function f to mock the RabbitQueue.ConsumeMessage method
func (mmConsumeMessage *mRabbitQueueMockConsumeMessage) Set(f func(consumerName string, messageConsume CbMsgConsume)) *RabbitQueueMock {
	if mmConsumeMessage.defaultExpectation != nil {
		mmConsumeMessage.mock.t.Fatalf("Default expectation is already set for the RabbitQueue.ConsumeMessage method")
	}

	if len(mmConsumeMessage.expectations) > 0 {
		mmConsumeMessage.mock.t.Fatalf("Some expectations are already set for the RabbitQueue.ConsumeMessage method")
	}

	mmConsumeMessage.mock.funcConsumeMessage = f
	return mmConsumeMessage.mock
}

// ConsumeMessage implements RabbitQueue
func (mmConsumeMessage *RabbitQueueMock) ConsumeMessage(consumerName string, messageConsume CbMsgConsume) {
	mm_atomic.AddUint64(&mmConsumeMessage.beforeConsumeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmConsumeMessage.afterConsumeMessageCounter, 1)

	if mmConsumeMessage.inspectFuncConsumeMessage != nil {
		mmConsumeMessage.inspectFuncConsumeMessage(consumerName, messageConsume)
	}

	mm_params := &RabbitQueueMockConsumeMessageParams{consumerName, messageConsume}

	// Record call args
	mmConsumeMessage.ConsumeMessageMock.mutex.Lock()
	mmConsumeMessage.ConsumeMessageMock.callArgs = append(mmConsumeMessage.ConsumeMessageMock.callArgs, mm_params)
	mmConsumeMessage.ConsumeMessageMock.mutex.Unlock()

	for _, e := range mmConsumeMessage.ConsumeMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmConsumeMessage.ConsumeMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConsumeMessage.ConsumeMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmConsumeMessage.ConsumeMessageMock.defaultExpectation.params
		mm_got := RabbitQueueMockConsumeMessageParams{consumerName, messageConsume}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConsumeMessage.t.Errorf("RabbitQueueMock.ConsumeMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmConsumeMessage.funcConsumeMessage != nil {
		mmConsumeMessage.funcConsumeMessage(consumerName, messageConsume)
		return
	}
	mmConsumeMessage.t.Fatalf("Unexpected call to RabbitQueueMock.ConsumeMessage. %v %v", consumerName, messageConsume)

}

// ConsumeMessageAfterCounter returns a count of finished RabbitQueueMock.ConsumeMessage invocations
func (mmConsumeMessage *RabbitQueueMock) ConsumeMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConsumeMessage.afterConsumeMessageCounter)
}

// ConsumeMessageBeforeCounter returns a count of RabbitQueueMock.ConsumeMessage invocations
func (mmConsumeMessage *RabbitQueueMock) ConsumeMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConsumeMessage.beforeConsumeMessageCounter)
}

// Calls returns a list of arguments used in each call to RabbitQueueMock.ConsumeMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConsumeMessage *mRabbitQueueMockConsumeMessage) Calls() []*RabbitQueueMockConsumeMessageParams {
	mmConsumeMessage.mutex.RLock()

	argCopy := make([]*RabbitQueueMockConsumeMessageParams, len(mmConsumeMessage.callArgs))
	copy(argCopy, mmConsumeMessage.callArgs)

	mmConsumeMessage.mutex.RUnlock()

	return argCopy
}

// MinimockConsumeMessageDone returns true if the count of the ConsumeMessage invocations corresponds
// the number of defined expectations
func (m *RabbitQueueMock) MinimockConsumeMessageDone() bool {
	for _, e := range m.ConsumeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConsumeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConsumeMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConsumeMessage != nil && mm_atomic.LoadUint64(&m.afterConsumeMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockConsumeMessageInspect logs each unmet expectation
func (m *RabbitQueueMock) MinimockConsumeMessageInspect() {
	for _, e := range m.ConsumeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RabbitQueueMock.ConsumeMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConsumeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConsumeMessageCounter) < 1 {
		if m.ConsumeMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RabbitQueueMock.ConsumeMessage")
		} else {
			m.t.Errorf("Expected call to RabbitQueueMock.ConsumeMessage with params: %#v", *m.ConsumeMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConsumeMessage != nil && mm_atomic.LoadUint64(&m.afterConsumeMessageCounter) < 1 {
		m.t.Error("Expected call to RabbitQueueMock.ConsumeMessage")
	}
}

type mRabbitQueueMockConsumeRPC struct {
	mock               *RabbitQueueMock
	defaultExpectation *RabbitQueueMockConsumeRPCExpectation
	expectations       []*RabbitQueueMockConsumeRPCExpectation

	callArgs []*RabbitQueueMockConsumeRPCParams
	mutex    sync.RWMutex
}

// RabbitQueueMockConsumeRPCExpectation specifies expectation struct of the RabbitQueue.ConsumeRPC
type RabbitQueueMockConsumeRPCExpectation struct {
	mock   *RabbitQueueMock
	params *RabbitQueueMockConsumeRPCParams

	Counter uint64
}

// RabbitQueueMockConsumeRPCParams contains parameters of the RabbitQueue.ConsumeRPC
type RabbitQueueMockConsumeRPCParams struct {
	consumerName string
	cbRPC        CbMsgRPC
}

// Expect sets up expected params for RabbitQueue.ConsumeRPC
func (mmConsumeRPC *mRabbitQueueMockConsumeRPC) Expect(consumerName string, cbRPC CbMsgRPC) *mRabbitQueueMockConsumeRPC {
	if mmConsumeRPC.mock.funcConsumeRPC != nil {
		mmConsumeRPC.mock.t.Fatalf("RabbitQueueMock.ConsumeRPC mock is already set by Set")
	}

	if mmConsumeRPC.defaultExpectation == nil {
		mmConsumeRPC.defaultExpectation = &RabbitQueueMockConsumeRPCExpectation{}
	}

	mmConsumeRPC.defaultExpectation.params = &RabbitQueueMockConsumeRPCParams{consumerName, cbRPC}
	for _, e := range mmConsumeRPC.expectations {
		if minimock.Equal(e.params, mmConsumeRPC.defaultExpectation.params) {
			mmConsumeRPC.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConsumeRPC.defaultExpectation.params)
		}
	}

	return mmConsumeRPC
}

// Inspect accepts an inspector function that has same arguments as the RabbitQueue.ConsumeRPC
func (mmConsumeRPC *mRabbitQueueMockConsumeRPC) Inspect(f func(consumerName string, cbRPC CbMsgRPC)) *mRabbitQueueMockConsumeRPC {
	if mmConsumeRPC.mock.inspectFuncConsumeRPC != nil {
		mmConsumeRPC.mock.t.Fatalf("Inspect function is already set for RabbitQueueMock.ConsumeRPC")
	}

	mmConsumeRPC.mock.inspectFuncConsumeRPC = f

	return mmConsumeRPC
}

// Return sets up results that will be returned by RabbitQueue.ConsumeRPC
func (mmConsumeRPC *mRabbitQueueMockConsumeRPC) Return() *RabbitQueueMock {
	if mmConsumeRPC.mock.funcConsumeRPC != nil {
		mmConsumeRPC.mock.t.Fatalf("RabbitQueueMock.ConsumeRPC mock is already set by Set")
	}

	if mmConsumeRPC.defaultExpectation == nil {
		mmConsumeRPC.defaultExpectation = &RabbitQueueMockConsumeRPCExpectation{mock: mmConsumeRPC.mock}
	}

	return mmConsumeRPC.mock
}

//Set uses given function f to mock the RabbitQueue.ConsumeRPC method
func (mmConsumeRPC *mRabbitQueueMockConsumeRPC) Set(f func(consumerName string, cbRPC CbMsgRPC)) *RabbitQueueMock {
	if mmConsumeRPC.defaultExpectation != nil {
		mmConsumeRPC.mock.t.Fatalf("Default expectation is already set for the RabbitQueue.ConsumeRPC method")
	}

	if len(mmConsumeRPC.expectations) > 0 {
		mmConsumeRPC.mock.t.Fatalf("Some expectations are already set for the RabbitQueue.ConsumeRPC method")
	}

	mmConsumeRPC.mock.funcConsumeRPC = f
	return mmConsumeRPC.mock
}

// ConsumeRPC implements RabbitQueue
func (mmConsumeRPC *RabbitQueueMock) ConsumeRPC(consumerName string, cbRPC CbMsgRPC) {
	mm_atomic.AddUint64(&mmConsumeRPC.beforeConsumeRPCCounter, 1)
	defer mm_atomic.AddUint64(&mmConsumeRPC.afterConsumeRPCCounter, 1)

	if mmConsumeRPC.inspectFuncConsumeRPC != nil {
		mmConsumeRPC.inspectFuncConsumeRPC(consumerName, cbRPC)
	}

	mm_params := &RabbitQueueMockConsumeRPCParams{consumerName, cbRPC}

	// Record call args
	mmConsumeRPC.ConsumeRPCMock.mutex.Lock()
	mmConsumeRPC.ConsumeRPCMock.callArgs = append(mmConsumeRPC.ConsumeRPCMock.callArgs, mm_params)
	mmConsumeRPC.ConsumeRPCMock.mutex.Unlock()

	for _, e := range mmConsumeRPC.ConsumeRPCMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmConsumeRPC.ConsumeRPCMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConsumeRPC.ConsumeRPCMock.defaultExpectation.Counter, 1)
		mm_want := mmConsumeRPC.ConsumeRPCMock.defaultExpectation.params
		mm_got := RabbitQueueMockConsumeRPCParams{consumerName, cbRPC}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConsumeRPC.t.Errorf("RabbitQueueMock.ConsumeRPC got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmConsumeRPC.funcConsumeRPC != nil {
		mmConsumeRPC.funcConsumeRPC(consumerName, cbRPC)
		return
	}
	mmConsumeRPC.t.Fatalf("Unexpected call to RabbitQueueMock.ConsumeRPC. %v %v", consumerName, cbRPC)

}

// ConsumeRPCAfterCounter returns a count of finished RabbitQueueMock.ConsumeRPC invocations
func (mmConsumeRPC *RabbitQueueMock) ConsumeRPCAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConsumeRPC.afterConsumeRPCCounter)
}

// ConsumeRPCBeforeCounter returns a count of RabbitQueueMock.ConsumeRPC invocations
func (mmConsumeRPC *RabbitQueueMock) ConsumeRPCBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConsumeRPC.beforeConsumeRPCCounter)
}

// Calls returns a list of arguments used in each call to RabbitQueueMock.ConsumeRPC.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConsumeRPC *mRabbitQueueMockConsumeRPC) Calls() []*RabbitQueueMockConsumeRPCParams {
	mmConsumeRPC.mutex.RLock()

	argCopy := make([]*RabbitQueueMockConsumeRPCParams, len(mmConsumeRPC.callArgs))
	copy(argCopy, mmConsumeRPC.callArgs)

	mmConsumeRPC.mutex.RUnlock()

	return argCopy
}

// MinimockConsumeRPCDone returns true if the count of the ConsumeRPC invocations corresponds
// the number of defined expectations
func (m *RabbitQueueMock) MinimockConsumeRPCDone() bool {
	for _, e := range m.ConsumeRPCMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConsumeRPCMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConsumeRPCCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConsumeRPC != nil && mm_atomic.LoadUint64(&m.afterConsumeRPCCounter) < 1 {
		return false
	}
	return true
}

// MinimockConsumeRPCInspect logs each unmet expectation
func (m *RabbitQueueMock) MinimockConsumeRPCInspect() {
	for _, e := range m.ConsumeRPCMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RabbitQueueMock.ConsumeRPC with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConsumeRPCMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConsumeRPCCounter) < 1 {
		if m.ConsumeRPCMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RabbitQueueMock.ConsumeRPC")
		} else {
			m.t.Errorf("Expected call to RabbitQueueMock.ConsumeRPC with params: %#v", *m.ConsumeRPCMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConsumeRPC != nil && mm_atomic.LoadUint64(&m.afterConsumeRPCCounter) < 1 {
		m.t.Error("Expected call to RabbitQueueMock.ConsumeRPC")
	}
}

type mRabbitQueueMockPublishMessage struct {
	mock               *RabbitQueueMock
	defaultExpectation *RabbitQueueMockPublishMessageExpectation
	expectations       []*RabbitQueueMockPublishMessageExpectation

	callArgs []*RabbitQueueMockPublishMessageParams
	mutex    sync.RWMutex
}

// RabbitQueueMockPublishMessageExpectation specifies expectation struct of the RabbitQueue.PublishMessage
type RabbitQueueMockPublishMessageExpectation struct {
	mock   *RabbitQueueMock
	params *RabbitQueueMockPublishMessageParams

	Counter uint64
}

// RabbitQueueMockPublishMessageParams contains parameters of the RabbitQueue.PublishMessage
type RabbitQueueMockPublishMessageParams struct {
	message string
}

// Expect sets up expected params for RabbitQueue.PublishMessage
func (mmPublishMessage *mRabbitQueueMockPublishMessage) Expect(message string) *mRabbitQueueMockPublishMessage {
	if mmPublishMessage.mock.funcPublishMessage != nil {
		mmPublishMessage.mock.t.Fatalf("RabbitQueueMock.PublishMessage mock is already set by Set")
	}

	if mmPublishMessage.defaultExpectation == nil {
		mmPublishMessage.defaultExpectation = &RabbitQueueMockPublishMessageExpectation{}
	}

	mmPublishMessage.defaultExpectation.params = &RabbitQueueMockPublishMessageParams{message}
	for _, e := range mmPublishMessage.expectations {
		if minimock.Equal(e.params, mmPublishMessage.defaultExpectation.params) {
			mmPublishMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishMessage.defaultExpectation.params)
		}
	}

	return mmPublishMessage
}

// Inspect accepts an inspector function that has same arguments as the RabbitQueue.PublishMessage
func (mmPublishMessage *mRabbitQueueMockPublishMessage) Inspect(f func(message string)) *mRabbitQueueMockPublishMessage {
	if mmPublishMessage.mock.inspectFuncPublishMessage != nil {
		mmPublishMessage.mock.t.Fatalf("Inspect function is already set for RabbitQueueMock.PublishMessage")
	}

	mmPublishMessage.mock.inspectFuncPublishMessage = f

	return mmPublishMessage
}

// Return sets up results that will be returned by RabbitQueue.PublishMessage
func (mmPublishMessage *mRabbitQueueMockPublishMessage) Return() *RabbitQueueMock {
	if mmPublishMessage.mock.funcPublishMessage != nil {
		mmPublishMessage.mock.t.Fatalf("RabbitQueueMock.PublishMessage mock is already set by Set")
	}

	if mmPublishMessage.defaultExpectation == nil {
		mmPublishMessage.defaultExpectation = &RabbitQueueMockPublishMessageExpectation{mock: mmPublishMessage.mock}
	}

	return mmPublishMessage.mock
}

//Set uses given function f to mock the RabbitQueue.PublishMessage method
func (mmPublishMessage *mRabbitQueueMockPublishMessage) Set(f func(message string)) *RabbitQueueMock {
	if mmPublishMessage.defaultExpectation != nil {
		mmPublishMessage.mock.t.Fatalf("Default expectation is already set for the RabbitQueue.PublishMessage method")
	}

	if len(mmPublishMessage.expectations) > 0 {
		mmPublishMessage.mock.t.Fatalf("Some expectations are already set for the RabbitQueue.PublishMessage method")
	}

	mmPublishMessage.mock.funcPublishMessage = f
	return mmPublishMessage.mock
}

// PublishMessage implements RabbitQueue
func (mmPublishMessage *RabbitQueueMock) PublishMessage(message string) {
	mm_atomic.AddUint64(&mmPublishMessage.beforePublishMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishMessage.afterPublishMessageCounter, 1)

	if mmPublishMessage.inspectFuncPublishMessage != nil {
		mmPublishMessage.inspectFuncPublishMessage(message)
	}

	mm_params := &RabbitQueueMockPublishMessageParams{message}

	// Record call args
	mmPublishMessage.PublishMessageMock.mutex.Lock()
	mmPublishMessage.PublishMessageMock.callArgs = append(mmPublishMessage.PublishMessageMock.callArgs, mm_params)
	mmPublishMessage.PublishMessageMock.mutex.Unlock()

	for _, e := range mmPublishMessage.PublishMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPublishMessage.PublishMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishMessage.PublishMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishMessage.PublishMessageMock.defaultExpectation.params
		mm_got := RabbitQueueMockPublishMessageParams{message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishMessage.t.Errorf("RabbitQueueMock.PublishMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPublishMessage.funcPublishMessage != nil {
		mmPublishMessage.funcPublishMessage(message)
		return
	}
	mmPublishMessage.t.Fatalf("Unexpected call to RabbitQueueMock.PublishMessage. %v", message)

}

// PublishMessageAfterCounter returns a count of finished RabbitQueueMock.PublishMessage invocations
func (mmPublishMessage *RabbitQueueMock) PublishMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishMessage.afterPublishMessageCounter)
}

// PublishMessageBeforeCounter returns a count of RabbitQueueMock.PublishMessage invocations
func (mmPublishMessage *RabbitQueueMock) PublishMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishMessage.beforePublishMessageCounter)
}

// Calls returns a list of arguments used in each call to RabbitQueueMock.PublishMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishMessage *mRabbitQueueMockPublishMessage) Calls() []*RabbitQueueMockPublishMessageParams {
	mmPublishMessage.mutex.RLock()

	argCopy := make([]*RabbitQueueMockPublishMessageParams, len(mmPublishMessage.callArgs))
	copy(argCopy, mmPublishMessage.callArgs)

	mmPublishMessage.mutex.RUnlock()

	return argCopy
}

// MinimockPublishMessageDone returns true if the count of the PublishMessage invocations corresponds
// the number of defined expectations
func (m *RabbitQueueMock) MinimockPublishMessageDone() bool {
	for _, e := range m.PublishMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishMessage != nil && mm_atomic.LoadUint64(&m.afterPublishMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockPublishMessageInspect logs each unmet expectation
func (m *RabbitQueueMock) MinimockPublishMessageInspect() {
	for _, e := range m.PublishMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RabbitQueueMock.PublishMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PublishMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPublishMessageCounter) < 1 {
		if m.PublishMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RabbitQueueMock.PublishMessage")
		} else {
			m.t.Errorf("Expected call to RabbitQueueMock.PublishMessage with params: %#v", *m.PublishMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishMessage != nil && mm_atomic.LoadUint64(&m.afterPublishMessageCounter) < 1 {
		m.t.Error("Expected call to RabbitQueueMock.PublishMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RabbitQueueMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockConnectInspect()

		m.MinimockConsumeMessageInspect()

		m.MinimockConsumeRPCInspect()

		m.MinimockPublishMessageInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RabbitQueueMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RabbitQueueMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockConnectDone() &&
		m.MinimockConsumeMessageDone() &&
		m.MinimockConsumeRPCDone() &&
		m.MinimockPublishMessageDone()
}
