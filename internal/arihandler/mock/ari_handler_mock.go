package mock

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

//go:generate minimock -i gitlab.com/voipbin/bin-manager/call-manager/internal/arihandler.ARIHandler -o ./mock/ari_handler_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ARIHandlerMock implements arihandler.ARIHandler
type ARIHandlerMock struct {
	t minimock.Tester

	funcReceiveEventQueue          func(addr string, queue string, receiver string)
	inspectFuncReceiveEventQueue   func(addr string, queue string, receiver string)
	afterReceiveEventQueueCounter  uint64
	beforeReceiveEventQueueCounter uint64
	ReceiveEventQueueMock          mARIHandlerMockReceiveEventQueue
}

// NewARIHandlerMock returns a mock for arihandler.ARIHandler
func NewARIHandlerMock(t minimock.Tester) *ARIHandlerMock {
	m := &ARIHandlerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ReceiveEventQueueMock = mARIHandlerMockReceiveEventQueue{mock: m}
	m.ReceiveEventQueueMock.callArgs = []*ARIHandlerMockReceiveEventQueueParams{}

	return m
}

type mARIHandlerMockReceiveEventQueue struct {
	mock               *ARIHandlerMock
	defaultExpectation *ARIHandlerMockReceiveEventQueueExpectation
	expectations       []*ARIHandlerMockReceiveEventQueueExpectation

	callArgs []*ARIHandlerMockReceiveEventQueueParams
	mutex    sync.RWMutex
}

// ARIHandlerMockReceiveEventQueueExpectation specifies expectation struct of the ARIHandler.ReceiveEventQueue
type ARIHandlerMockReceiveEventQueueExpectation struct {
	mock   *ARIHandlerMock
	params *ARIHandlerMockReceiveEventQueueParams

	Counter uint64
}

// ARIHandlerMockReceiveEventQueueParams contains parameters of the ARIHandler.ReceiveEventQueue
type ARIHandlerMockReceiveEventQueueParams struct {
	addr     string
	queue    string
	receiver string
}

// Expect sets up expected params for ARIHandler.ReceiveEventQueue
func (mmReceiveEventQueue *mARIHandlerMockReceiveEventQueue) Expect(addr string, queue string, receiver string) *mARIHandlerMockReceiveEventQueue {
	if mmReceiveEventQueue.mock.funcReceiveEventQueue != nil {
		mmReceiveEventQueue.mock.t.Fatalf("ARIHandlerMock.ReceiveEventQueue mock is already set by Set")
	}

	if mmReceiveEventQueue.defaultExpectation == nil {
		mmReceiveEventQueue.defaultExpectation = &ARIHandlerMockReceiveEventQueueExpectation{}
	}

	mmReceiveEventQueue.defaultExpectation.params = &ARIHandlerMockReceiveEventQueueParams{addr, queue, receiver}
	for _, e := range mmReceiveEventQueue.expectations {
		if minimock.Equal(e.params, mmReceiveEventQueue.defaultExpectation.params) {
			mmReceiveEventQueue.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceiveEventQueue.defaultExpectation.params)
		}
	}

	return mmReceiveEventQueue
}

// Inspect accepts an inspector function that has same arguments as the ARIHandler.ReceiveEventQueue
func (mmReceiveEventQueue *mARIHandlerMockReceiveEventQueue) Inspect(f func(addr string, queue string, receiver string)) *mARIHandlerMockReceiveEventQueue {
	if mmReceiveEventQueue.mock.inspectFuncReceiveEventQueue != nil {
		mmReceiveEventQueue.mock.t.Fatalf("Inspect function is already set for ARIHandlerMock.ReceiveEventQueue")
	}

	mmReceiveEventQueue.mock.inspectFuncReceiveEventQueue = f

	return mmReceiveEventQueue
}

// Return sets up results that will be returned by ARIHandler.ReceiveEventQueue
func (mmReceiveEventQueue *mARIHandlerMockReceiveEventQueue) Return() *ARIHandlerMock {
	if mmReceiveEventQueue.mock.funcReceiveEventQueue != nil {
		mmReceiveEventQueue.mock.t.Fatalf("ARIHandlerMock.ReceiveEventQueue mock is already set by Set")
	}

	if mmReceiveEventQueue.defaultExpectation == nil {
		mmReceiveEventQueue.defaultExpectation = &ARIHandlerMockReceiveEventQueueExpectation{mock: mmReceiveEventQueue.mock}
	}

	return mmReceiveEventQueue.mock
}

//Set uses given function f to mock the ARIHandler.ReceiveEventQueue method
func (mmReceiveEventQueue *mARIHandlerMockReceiveEventQueue) Set(f func(addr string, queue string, receiver string)) *ARIHandlerMock {
	if mmReceiveEventQueue.defaultExpectation != nil {
		mmReceiveEventQueue.mock.t.Fatalf("Default expectation is already set for the ARIHandler.ReceiveEventQueue method")
	}

	if len(mmReceiveEventQueue.expectations) > 0 {
		mmReceiveEventQueue.mock.t.Fatalf("Some expectations are already set for the ARIHandler.ReceiveEventQueue method")
	}

	mmReceiveEventQueue.mock.funcReceiveEventQueue = f
	return mmReceiveEventQueue.mock
}

// ReceiveEventQueue implements arihandler.ARIHandler
func (mmReceiveEventQueue *ARIHandlerMock) ReceiveEventQueue(addr string, queue string, receiver string) {
	mm_atomic.AddUint64(&mmReceiveEventQueue.beforeReceiveEventQueueCounter, 1)
	defer mm_atomic.AddUint64(&mmReceiveEventQueue.afterReceiveEventQueueCounter, 1)

	if mmReceiveEventQueue.inspectFuncReceiveEventQueue != nil {
		mmReceiveEventQueue.inspectFuncReceiveEventQueue(addr, queue, receiver)
	}

	mm_params := &ARIHandlerMockReceiveEventQueueParams{addr, queue, receiver}

	// Record call args
	mmReceiveEventQueue.ReceiveEventQueueMock.mutex.Lock()
	mmReceiveEventQueue.ReceiveEventQueueMock.callArgs = append(mmReceiveEventQueue.ReceiveEventQueueMock.callArgs, mm_params)
	mmReceiveEventQueue.ReceiveEventQueueMock.mutex.Unlock()

	for _, e := range mmReceiveEventQueue.ReceiveEventQueueMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmReceiveEventQueue.ReceiveEventQueueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceiveEventQueue.ReceiveEventQueueMock.defaultExpectation.Counter, 1)
		mm_want := mmReceiveEventQueue.ReceiveEventQueueMock.defaultExpectation.params
		mm_got := ARIHandlerMockReceiveEventQueueParams{addr, queue, receiver}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceiveEventQueue.t.Errorf("ARIHandlerMock.ReceiveEventQueue got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmReceiveEventQueue.funcReceiveEventQueue != nil {
		mmReceiveEventQueue.funcReceiveEventQueue(addr, queue, receiver)
		return
	}
	mmReceiveEventQueue.t.Fatalf("Unexpected call to ARIHandlerMock.ReceiveEventQueue. %v %v %v", addr, queue, receiver)

}

// ReceiveEventQueueAfterCounter returns a count of finished ARIHandlerMock.ReceiveEventQueue invocations
func (mmReceiveEventQueue *ARIHandlerMock) ReceiveEventQueueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveEventQueue.afterReceiveEventQueueCounter)
}

// ReceiveEventQueueBeforeCounter returns a count of ARIHandlerMock.ReceiveEventQueue invocations
func (mmReceiveEventQueue *ARIHandlerMock) ReceiveEventQueueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceiveEventQueue.beforeReceiveEventQueueCounter)
}

// Calls returns a list of arguments used in each call to ARIHandlerMock.ReceiveEventQueue.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceiveEventQueue *mARIHandlerMockReceiveEventQueue) Calls() []*ARIHandlerMockReceiveEventQueueParams {
	mmReceiveEventQueue.mutex.RLock()

	argCopy := make([]*ARIHandlerMockReceiveEventQueueParams, len(mmReceiveEventQueue.callArgs))
	copy(argCopy, mmReceiveEventQueue.callArgs)

	mmReceiveEventQueue.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveEventQueueDone returns true if the count of the ReceiveEventQueue invocations corresponds
// the number of defined expectations
func (m *ARIHandlerMock) MinimockReceiveEventQueueDone() bool {
	for _, e := range m.ReceiveEventQueueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveEventQueueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveEventQueueCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveEventQueue != nil && mm_atomic.LoadUint64(&m.afterReceiveEventQueueCounter) < 1 {
		return false
	}
	return true
}

// MinimockReceiveEventQueueInspect logs each unmet expectation
func (m *ARIHandlerMock) MinimockReceiveEventQueueInspect() {
	for _, e := range m.ReceiveEventQueueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ARIHandlerMock.ReceiveEventQueue with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveEventQueueMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReceiveEventQueueCounter) < 1 {
		if m.ReceiveEventQueueMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ARIHandlerMock.ReceiveEventQueue")
		} else {
			m.t.Errorf("Expected call to ARIHandlerMock.ReceiveEventQueue with params: %#v", *m.ReceiveEventQueueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceiveEventQueue != nil && mm_atomic.LoadUint64(&m.afterReceiveEventQueueCounter) < 1 {
		m.t.Error("Expected call to ARIHandlerMock.ReceiveEventQueue")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ARIHandlerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockReceiveEventQueueInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ARIHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ARIHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockReceiveEventQueueDone()
}
